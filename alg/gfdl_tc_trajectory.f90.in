module gfdl_tc_trajectory_@type_name@_mod
use iso_c_binding
use iso_fortran_env, ONLY : error_unit
use teca_tc_trajectory_util_mod
use teca_vector_long_mod
implicit none

private
public :: gfdl_tc_trajectory_@type_name@

real(@c_type_coord@), parameter :: &
  EARTH_RADIUS = 6371.0, DEG_TO_RAD = 3.14159265358979/180.0

interface
!-----------------------------------------------------------------------------
subroutine teca_append_tc_track_@type_name@(table, track_id, storm_id, &
  step, time, lon, lat, psl, wind, vort, have_twc, have_thick, twc, thick) &
  bind(C)
  use iso_c_binding
  implicit none
  type(c_ptr), intent(in) :: table
  integer(c_long), intent(in) :: step
  real(c_double), intent(in) :: time
  real(@c_type_coord@), intent(in) :: lon, lat
  integer(c_int), intent(in) :: track_id, storm_id, have_twc, have_thick
  real(@c_type_var@), intent(in) :: psl, wind, vort, twc, thick
end subroutine
end interface


contains


!-----------------------------------------------------------------------------
pure function distance_@type_name@( &
  r_lon_0, r_lat_0, r_lon_i, r_lat_i) result(dr) bind(C)
  implicit none
  real(@c_type_coord@), intent(in) :: &
    r_lon_0, r_lat_0, r_lon_i, r_lat_i
  real(@c_type_coord@) :: dr, dx, dy

  ! GFDL 2007
  dx = (r_lon_i - r_lon_0)*cos(r_lat_0)
  dy = (r_lat_i - r_lat_0)
  dr = EARTH_RADIUS*sqrt(dx*dx + dy*dy)

  ! GFDL 2015
  !dr = EARTH_RADIUS*acos(sin(r_lat_0)*sin(r_lat_i) &
  !  + cos(r_lat_0)*cos(r_lat_i)*cos(r_lon_i - r_lon_0))

  ! haversine formula
  !dx = r_lon_i - r_lon_0
  !dy = r_lat_i - r_lat_0
  !dr = EARTH_RADIUS*2.0*asin(min(1,sqrt(sin(dy/2.0)**2.0 &
  !  + cos(r_lat_0)*cos(r_lat_i)*sin(dx/2.0)**2.0)))
end function



!-----------------------------------------------------------------------------
! defaults
!  r_crit  = 900.0
!  wind_crit  = 17.0
!  wind_max_crit = 17.0
!  vort_crit  = 3.5e-5  !miz
!  twc_crit   =  0.5 !miz
!  thick_crit =  50. !miz
!  n_wind_crit  =   2
!  do_filt = .true.
!  nlat =  40. !miz
!  slat = -40. !miz
integer(c_int) function gfdl_tc_trajectory_@type_name@( &
  r_crit, wind_crit, n_wind_crit, time_step, time, storm_uid, &
  d_lon, d_lat, wind_max, vort_max, psl, have_twc, &
  have_thick, twc_max, thick_max, n_rows, track_table) &
  result(ret_val) bind(C)
  use iso_c_binding
  use iso_fortran_env, only : error_unit
  implicit none

  type(c_ptr), intent(in) :: track_table
  real(@c_type_coord@), intent(in) :: r_crit

  real(@c_type_var@), intent(in) :: wind_crit, n_wind_crit

  integer(c_long), intent(in) :: n_rows

  real(@c_type_coord@), intent(in), dimension(n_rows) :: &
    d_lon, d_lat

  real(c_double), intent(in), dimension(n_rows) :: time
  integer(c_long), intent(in), dimension(n_rows) :: time_step

  real(@c_type_var@), intent(in), dimension(n_rows) :: &
    wind_max, vort_max, psl, twc_max, thick_max

  integer(c_int), intent(in), dimension(n_rows) :: &
    storm_uid, have_twc, have_thick

  real(@c_type_coord@) :: r_lon_0, r_lat_0, r_lon_i, r_lat_i
  real(c_double) :: dt, drdt, t_0, t_i

  logical :: cross_equator

  integer(c_long) :: step, storm, n_steps, n_steps_m1, &
    next_step, next_storm, track_len, curr_step, curr_storm, &
    n_cand, n_bon, n_wind, q, idx_0, idx_i, n_thick, n_twc

  integer(c_int) :: track_id

  integer(c_long), dimension(1) :: imin

  integer(c_long),dimension(n_rows) :: step_offsets, &
    step_counts

  integer(c_long), dimension(n_rows) :: &
    track_step, track_storm, cand_step, cand_storm, &
    bon_step, bon_storm

  real(@c_type_coord@), dimension(n_rows) :: rtot, r_lon, r_lat

  logical, dimension(n_rows) :: available, exist_wind, exist_twc, exist_thick

  type(teca_vector_long) :: track_starts, new_track
  integer(c_long) :: track_start, track_tip, closest_storm_id, &
    active_step, i, j, n_storms, storm_id, max_track_len
  logical :: success
  real(@c_type_coord@) :: lon_0, lat_0, lon_i, lat_i, storm_dist, closest_storm_dist

  ret_val = -1

  track_id = 0

  ! Generate masks from critical values
  exist_wind(:) = (wind_max(:) .ge. wind_crit)
  exist_twc(:) = (have_twc(:) .ne. 0)
  exist_thick(:) = (have_thick(:) .ne. 0)
  r_lon(:) = DEG_TO_RAD*d_lon(:)
  r_lat(:) = DEG_TO_RAD*d_lat(:)
  available(:) = .true.

  ! build offset to time step table
  call get_step_offsets(time_step, n_rows, &
    n_steps, step_counts, step_offsets)

  ! build the track start queue.
  ! consider all tracks eminating from all storms.
  ! as tracks form these are marked as used
  call teca_vector_long_init(track_starts, n_rows)
  do i = n_rows,1,-1
    call teca_vector_long_push_back(track_starts, i)
  enddo

  do while (teca_vector_long_size(track_starts) .gt. 0)
    ! for each potential track start
    track_start = teca_vector_long_back(track_starts)
    call teca_vector_long_pop_back(track_starts)
    if (available(track_start)) then
      ! this storm is not part of another track is now considered
      ! whether or not it works out it is no longer available for
      ! use in other tracks
      available(track_start) = .false.

      ! start the new track
      max_track_len =  n_steps - time_step(track_start)
      call teca_vector_long_init(new_track, max_track_len)
      call teca_vector_long_push_back(new_track, track_start)

      ! now walk forward in time examining each storm in the
      ! next time step.active step is next one forward in time
      active_step = time_step(track_start) + 2
      do j = active_step, n_steps

        ! get position of the end of the track
        track_tip = teca_vector_long_back(new_track)

        lon_0 = r_lon(track_tip)
        lat_0 = r_lat(track_tip)

        ! find the closest storm
        closest_storm_id = 0
        closest_storm_dist = r_crit
        success = .false.

        n_storms = step_counts(j) - 1
        do i = 0,n_storms
          ! check the storms distance. check them all since
          ! we need the closest
          storm_id = step_offsets(j) + i

          ! skip storms that are already part of other tracks
          if (.not. available(storm_id)) &
            cycle

          lon_i = r_lon(storm_id)
          lat_i = r_lat(storm_id)

          ! compute the distance to the track tip
          storm_dist = distance_@type_name@(lon_0, lat_0, lon_i, lat_i)

          if (storm_dist .le. closest_storm_dist) then
            ! found one that's at least as close as
            closest_storm_id = storm_id
            closest_storm_dist = storm_dist
            success = .true.
          end if
        end do

        if (success) then
          ! we were able to extend this track
          call teca_vector_long_push_back(new_track, closest_storm_id)
          available(closest_storm_id) = .false.
        else
          ! track ends here
          exit
        end if
      enddo

      ! one track has been completed
      track_len = teca_vector_long_size(new_track)
      if (track_len .gt. 1) then
        ! output trajectory info
        call teca_vector_long_write(new_track, 'track', error_unit)

        do i = 1,track_len
          ! output trajectory info
          storm_id = new_track%m_data(i)

          call teca_append_tc_track_@type_name@( &
            track_table, track_id, storm_uid(storm_id), time_step(storm_id), &
            time(storm_id), d_lon(storm_id), d_lat(storm_id), psl(storm_id), &
            wind_max(storm_id), vort_max(storm_id), have_twc(storm_id), &
            have_thick(storm_id), twc_max(storm_id), thick_max(storm_id))
        end do

        track_id = track_id + 1
      endif

      ! free up memory for this track
      call teca_vector_long_clear(new_track)
    endif
  enddo

  ! free up memory
  call teca_vector_long_clear(track_starts)

  ret_val = 0
  return
end function




!-----------------------------------------------------------------------------
! defaults
!  r_crit  = 900.0
!  wind_crit  = 17.0
!  wind_max_crit = 17.0
!  vort_crit  = 3.5e-5  !miz
!  twc_crit   =  0.5 !miz
!  thick_crit =  50. !miz
!  n_wind_crit  =   2
!  do_filt = .true.
!  nlat =  40. !miz
!  slat = -40. !miz
integer(c_int) function gfdl_tc_trajectory_@type_name@_1( &
  r_crit, wind_crit, n_wind_crit, time_step, time, storm_id, &
  d_lon, d_lat, wind_max, vort_max, psl, have_twc, &
  have_thick, twc_max, thick_max, n_rows, track_table) &
  result(ret_val) bind(C)
  use iso_c_binding
  use iso_fortran_env, only : error_unit
  implicit none

  type(c_ptr), intent(in) :: track_table
  real(@c_type_coord@), intent(in) :: r_crit

  real(@c_type_var@), intent(in) :: wind_crit, n_wind_crit

  integer(c_long), intent(in) :: n_rows

  real(@c_type_coord@), intent(in), dimension(n_rows) :: &
    d_lon, d_lat

  real(c_double), intent(in), dimension(n_rows) :: time
  integer(c_long), intent(in), dimension(n_rows) :: time_step

  real(@c_type_var@), intent(in), dimension(n_rows) :: &
    wind_max, vort_max, psl, twc_max, thick_max

  integer(c_int), intent(in), dimension(n_rows) :: &
    storm_id, have_twc, have_thick

  real(@c_type_coord@) :: r_lon_0, r_lat_0, r_lon_i, r_lat_i
  real(c_double) :: dt, drdt, t_0, t_i

  logical :: cross_equator

  integer(c_long) :: step, storm, n_steps, n_steps_m1, &
    next_step, next_storm, track_len, curr_step, curr_storm, &
    n_cand, n_bon, n_wind, q, idx_0, idx_i, n_thick, n_twc

  integer(c_int) :: track_id

  integer(c_long), dimension(1) :: imin

  integer(c_long),dimension(n_rows) :: step_offsets, &
    step_counts

  integer(c_long), dimension(n_rows) :: &
    track_step, track_storm, cand_step, cand_storm, &
    bon_step, bon_storm

  real(@c_type_coord@), dimension(n_rows) :: rtot, r_lon, r_lat

  logical, dimension(n_rows) :: available, exist_wind, exist_twc, exist_thick


  ret_val = -1

  ! --- STEP 1: Generate masks from critical values
  exist_wind(:) = (wind_max(:) .ge. wind_crit)
  exist_twc(:) = (have_twc(:) .ne. 0)
  exist_thick(:) = (have_thick(:) .ne. 0)
  r_lon(:) = DEG_TO_RAD*d_lon(:)
  r_lat(:) = DEG_TO_RAD*d_lat(:)
  available(:) = .true.

  ! --- STEP 2: EVALUATION OF TRAJECTORIES
  call get_step_offsets(time_step, n_rows, &
    n_steps, step_offsets, step_counts)

  n_steps_m1 = n_steps - 1
  do step = 1,n_steps_m1
    write(error_unit,*)'processing step=',step,'with',step_counts(step),'storms'

    next_step = step + 1
    write(error_unit,*)'compare to next_step=',next_step,'with',step_counts(next_step),'storms'

    ! for each candidate
    do storm = 1,step_counts(step)

      track_len = 1
      track_step(1) = step
      track_storm(1) = storm

      idx_0 = step_offsets(step) + storm

      t_0 = time(idx_0)

      if (available(idx_0) .and. exist_wind(idx_0)) then

        curr_step = step
        curr_storm = storm

        ! look forward in time at all steps for track candidates
10      continue

        n_cand = 0

        if (next_step .le. n_steps) then
          ! --- check for candidates on following day
          idx_0 = step_offsets(curr_step) + curr_storm
          r_lon_0 = r_lon(idx_0)
          r_lat_0 = r_lat(idx_0)
          t_i = time(idx_0)
          dt = t_i - t_0

          ! build track candidate list. candidates must be
          ! close in space and time and not cross the equator
          do next_storm = 1,step_counts(next_step)

            idx_i = step_offsets(next_step) + next_storm

            write(error_unit,*)'compare it to',next_step,next_storm,idx_i

            if (available(idx_i)) then
              r_lon_i = r_lon(idx_i)
              r_lat_i = r_lat(idx_i)

              drdt = distance_@type_name@( &
                r_lon_0, r_lat_0, r_lon_i, r_lat_i)/dt

              cross_equator = (r_lat_i*r_lat_0 .le. 0.0)

              if ((drdt .le. r_crit) .and. (.not. cross_equator)) then
                n_cand = n_cand + 1
                cand_step(n_cand) = next_step
                cand_storm(n_cand) = next_storm
              end if
            end if
          end do
        endif

        ! no more candidate storms, end of the track
        if (n_cand .eq. 0) then
          ! check sustained winds along the trajectory
          n_wind = 0
          n_twc = 0
          n_thick = 0
          do q = 1,track_len
            idx_0 = step_offsets(track_step(q))+track_storm(q)

            if (exist_wind(idx_0) .and. &
              exist_twc(idx_0) .and. exist_thick(idx_0)) &
              n_wind = n_wind + 1

            if (exist_twc(idx_0)) &
              n_twc = n_twc + 1

            if (exist_thick(idx_0)) &
              n_thick = n_thick + 1
          end do

          dt = time(idx_0) - t_0
          if ((track_len .gt. 1) .and. ((n_wind*dt) .ge. n_wind_crit)) then
            ! track meets the wind duration criteria

            do q = 1,track_len
              idx_0 = step_offsets(track_step(q)) + track_storm(q)

              ! output trajectory info
              call teca_append_tc_track_@type_name@( &
                track_table, track_id, storm_id(idx_0), time_step(idx_0), &
                time(idx_0), d_lon(idx_0), d_lat(idx_0), psl(idx_0), &
                wind_max(idx_0), vort_max(idx_0), have_twc(idx_0), &
                have_thick(idx_0), twc_max(idx_0), thick_max(idx_0))

              ! mark candidate as used
              available(idx_0) = .false.
            end do

            track_id = track_id + 1
          end if
        end if

        ! one candidate storm, add it to the track
        if (n_cand .eq. 1) then

          track_len = track_len + 1
          track_step(track_len) = cand_step(1)
          track_storm(track_len) = cand_storm(1)

          curr_step = track_step(track_len)
          curr_storm = track_storm(track_len)

          ! done with this step, search the next one
          next_step = next_step + 1
          goto 10
        end if

        ! more than one candidate storm
        if (n_cand .gt. 1) then
          idx_0 = step_offsets(curr_step) + curr_storm

          r_lon_0 = r_lon(idx_0)
          r_lat_0 = abs(r_lat(idx_0))

          n_bon = 0

          do q = 1,n_cand
            idx_i = step_offsets(cand_step(q)) + cand_storm(q)

            r_lon_i = r_lon(idx_i)
            r_lat_i = abs(r_lat(idx_i))

            ! TODO -- is this the periodic bc in lon dir??
            ! mod to deal with 0 lon (from gfdl 2015)
            !if ((sin(r_lon_i) <= sin(r_lon_0)) &
            ! here is teca 1 condition
            if ((r_lon_i <= r_lon_0) &
              .and. (r_lat_i >= r_lat_0)) then
              n_bon = n_bon + 1
              bon_step(n_bon) = cand_step(q)
              bon_storm(n_bon) = cand_storm(q)
            end if
          end do

          if (n_bon .eq. 1) then
            ! add the storm to the track
            track_len = track_len + 1
            track_step(track_len) = bon_step(1)
            track_storm(track_len) = bon_storm(1)

            curr_step = track_step(track_len)
            curr_storm = track_storm(track_len)

            ! done with this step, search the next one
            next_step = next_step + 1
            goto 10
          end if

          if (n_bon .gt. 1) then
            ! take the closest
            idx_0 = step_offsets(curr_step) + curr_storm
            r_lon_0 = r_lon(idx_0)
            r_lat_0 = r_lat(idx_0)

            do q = 1,n_bon
              idx_i = step_offsets(bon_step(q)) + bon_storm(q)

              r_lon_i = r_lon(idx_i)
              r_lat_i = r_lat(idx_i)

              rtot(q) = distance_@type_name@( &
                r_lon_0, r_lat_0, r_lon_i, r_lat_i)
            end do
            imin = minloc(rtot(1:n_bon))

            ! add to track
            track_len = track_len + 1
            track_step(track_len) = bon_step(imin(1))
            track_storm(track_len) = bon_storm(imin(1))

            ! done with this step, search the next one
            curr_step = track_step(track_len)
            curr_storm = track_storm(track_len)
            next_step  = next_step + 1
            goto  10
          end if

          if (n_bon .eq. 0) then
            ! take the closest
            idx_0 = step_offsets(curr_step) + curr_storm

            r_lon_0 = r_lon(idx_0)
            r_lat_0 = r_lat(idx_0)

            do q = 1,n_cand
              idx_i = step_offsets(cand_step(q)) + cand_storm(q)

              r_lon_i = r_lon(idx_i)
              r_lat_i = r_lat(idx_i)

              rtot(q) = distance_@type_name@( &
                r_lon_0, r_lat_0, r_lon_i, r_lat_i)
            end do
            imin = minloc(rtot(1:n_cand))

            ! add to track
            track_len = track_len + 1
            track_step(track_len) = cand_step(imin(1))
            track_storm(track_len) = cand_storm(imin(1))

            ! done with this step, search the next one
            curr_step = track_step(track_len)
            curr_storm = track_storm(track_len)
            next_step = next_step + 1
            goto  10

          endif
        end if
      end if
    end do
    write(error_unit, '(A)')'done!'
  end do

  ! TODO -- these would go in downstream algorithms
  ! --- FILTER DATA
  !if (do_filt) CALL TS_FILTER(nlat,slat)
  ! --- STATS
  !call TS_STATS(do_filt)

  ret_val = 0
  return
end function
end module
