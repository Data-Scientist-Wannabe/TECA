module gfdl_tc_trajectory_@type_name@_mod
use iso_c_binding
use iso_fortran_env, ONLY : error_unit
use trajectory_util
implicit none

private
public :: gfdl_tc_trajectory_@type_name@

real(@c_type_coord@), parameter :: &
  EARTH_RADIUS = 6371.0, DEG_TO_RAD = 3.14159265358979/180.0

interface
!-----------------------------------------------------------------------------
subroutine teca_append_tc_track_@type_name@(table, track_id, storm_id, &
  step, time, lon, lat, psl, wind, vort, have_twc, have_thick, twc, thick) &
  bind(C)
  use iso_c_binding
  implicit none
  type(c_ptr), intent(in) :: table
  integer(c_long), intent(in) :: step
  real(c_double), intent(in) :: time
  real(@c_type_coord@), intent(in) :: lon, lat
  integer(c_int), intent(in) :: track_id, storm_id, have_twc, have_thick
  real(@c_type_var@), intent(in) :: psl, wind, vort, twc, thick
end subroutine
end interface

contains
!-----------------------------------------------------------------------------
pure function distance_@type_name@( &
  r_lon_0, r_lat_0, r_lon_i, r_lat_i) result(dr) bind(C)
  implicit none
  real(@c_type_coord@), intent(in) :: &
    r_lon_0, r_lat_0, r_lon_i, r_lat_i
  real(@c_type_coord@) :: dr, dx, dy

  ! GFDL 2007
  dx = (r_lon_i - r_lon_0)*cos(r_lat_0)
  dy = (r_lat_i - r_lat_0)
  dr = EARTH_RADIUS*sqrt(dx*dx + dy*dy)

  ! GFDL 2015
  !dr = EARTH_RADIUS*acos(sin(r_lat_0)*sin(r_lat_i) &
  !  + cos(r_lat_0)*cos(r_lat_i)*cos(r_lon_i - r_lon_0))

  ! haversine formula
  !dx = r_lon_i - r_lon_0
  !dy = r_lat_i - r_lat_0
  !dr = EARTH_RADIUS*2.0*asin(min(1,sqrt(sin(dy/2.0)**2.0 &
  !  + cos(r_lat_0)*cos(r_lat_i)*sin(dx/2.0)**2.0)))
end function

!-----------------------------------------------------------------------------
! defaults
!  r_crit  = 900.0
!  wind_crit  = 17.0
!  wind_max_crit = 17.0
!  vort_crit  = 3.5e-5  !miz
!  twc_crit   =  0.5 !miz
!  thick_crit =  50. !miz
!  n_wind_crit  =   2
!  do_filt = .true.
!  nlat =  40. !miz
!  slat = -40. !miz
integer(c_int) function gfdl_tc_trajectory_@type_name@( &
  r_crit, wind_crit, n_wind_crit, time_step, time, storm_id, &
  d_lon, d_lat, wind_max, vort_max, psl, have_twc, &
  have_thick, twc_max, thick_max, n_rows, track_table) &
  result(ret_val) bind(C)
  use iso_c_binding
  use iso_fortran_env, only : error_unit
  implicit none

  type(c_ptr), intent(in) :: track_table
  real(@c_type_coord@), intent(in) :: r_crit

  real(@c_type_var@), intent(in) :: wind_crit, n_wind_crit

  integer(c_long), intent(in) :: n_rows

  real(@c_type_coord@), intent(in), dimension(n_rows) :: &
    d_lon, d_lat

  real(c_double), intent(in), dimension(n_rows) :: time
  integer(c_long), intent(in), dimension(n_rows) :: time_step

  real(@c_type_var@), intent(in), dimension(n_rows) :: &
    wind_max, vort_max, psl, twc_max, thick_max

  integer(c_int), intent(in), dimension(n_rows) :: &
    storm_id, have_twc, have_thick

  real(@c_type_coord@) :: r_lon_0, r_lat_0, r_lon_i, r_lat_i
  real(c_double) :: dt, drdt

  logical :: cross_equator

  integer(c_long) :: step, storm, n_steps, n_steps_m1, &
    next_step, next_storm, track_len, curr_step, curr_storm, &
    n_cand, n_bon, n_wind, q, idx_0, idx_i, n_thick, n_twc

  integer(c_int) :: track_id

  integer(c_long), dimension(1) :: imin

  integer(c_long),dimension(n_rows) :: step_offsets, &
    step_counts

  integer(c_long), dimension(n_rows) :: &
    track_step, track_storm, cand_step, cand_storm, &
    bon_step, bon_storm

  real(@c_type_coord@), dimension(n_rows) :: rtot, r_lon, r_lat

  logical, dimension(n_rows) :: available, exist_wind, exist_twc, exist_thick


  ret_val = -1

  ! --- STEP 1: Generate masks from critical values
  exist_wind(:) = (wind_max(:) .ge. wind_crit)
  exist_twc(:) = (have_twc(:) .ne. 0)
  exist_thick(:) = (have_thick(:) .ne. 0)
  r_lon(:) = DEG_TO_RAD*d_lon(:)
  r_lat(:) = DEG_TO_RAD*d_lat(:)
  available(:) = .true.

  ! --- STEP 2: EVALUATION OF TRAJECTORIES
  call get_step_offsets(time_step, n_rows, &
    n_steps, step_offsets, step_counts)

  n_steps_m1 = n_steps - 1
  do step = 1,n_steps_m1
    write(error_unit, '(A5,I0,$)')'step=',step

    next_step = step + 1

    ! for each candidate
    do storm = 1,step_counts(step)

      track_len = 1
      track_step(1) = step
      track_storm(1) = storm

      idx_0 = step_offsets(step) + storm

      if (available(idx_0) .and. exist_wind(idx_0)) then

        curr_step = step
        curr_storm = storm

        ! look forward in time at all steps for track candidates
10      continue
        n_cand = 0

        if (next_step .le. n_steps) then
          ! --- check for candidates on following day
          idx_0 = step_offsets(curr_step)+curr_storm
          r_lon_0 = r_lon(idx_0)
          r_lat_0 = r_lat(idx_0)

          dt = time(next_step) - time(step)

          ! build track candidate list. candidates must be
          ! close in space and time and not cross the equator
          do next_storm = 1,step_counts(next_step)

            idx_i = step_offsets(next_step)+next_storm

            if (available(idx_i)) then
              r_lon_i = r_lon(idx_i)
              r_lat_i = r_lat(idx_i)

              drdt = distance_@type_name@( &
                r_lon_0, r_lat_0, r_lon_i, r_lat_i)/dt

              cross_equator = (r_lat_i*r_lat_0 .le. 0.0)

              if ((drdt .le. r_crit) .and. (.not. cross_equator)) then
                n_cand = n_cand + 1
                cand_step(n_cand) = next_step
                cand_storm(n_cand) = next_storm
              end if
            end if
          end do
        endif

        ! no more candidate storms, end of the track
        if (n_cand .eq. 0) then
          ! check sustained winds along the trajectory
          n_wind = 0
          !n_wind_max = 0
          n_twc = 0
          n_thick = 0
          do q = 1,track_len
            idx_0 = step_offsets(track_step(q))+track_storm(q)

            if (exist_wind(idx_0) .and. &
              exist_twc(idx_0) .and. exist_thick(idx_0)) &
              n_wind = n_wind + 1

            if (exist_twc(idx_0)) &
              n_twc = n_twc + 1

            if (exist_thick(idx_0)) &
              n_thick = n_thick + 1

          end do

          dt = time(next_step) - time(step)
          if ((track_len .gt. 1) .and. ((n_wind*dt) .ge. n_wind_crit)) then
            ! track meets the wind duration criteria

            do q = 1,track_len
              idx_0 = step_offsets(track_step(q)) + track_storm(q)

              ! output trajectory info
              call teca_append_tc_track_@type_name@( &
                track_table, track_id, storm_id(idx_0), time_step(idx_0), &
                time(idx_0), d_lon(idx_0), d_lat(idx_0), psl(idx_0), &
                wind_max(idx_0), vort_max(idx_0), have_twc(idx_0), &
                have_thick(idx_0), twc_max(idx_0), thick_max(idx_0))

              ! mark candidate as used
              available(idx_0) = .false.
            end do

            track_id = track_id + 1
          end if
        end if

        ! one candidate storm, add it to the track
        if (n_cand .eq. 1) then

          track_len = track_len + 1
          track_step(track_len) = cand_step(1)
          track_storm(track_len) = cand_storm(1)

          curr_step = track_step(track_len)
          curr_storm = track_storm(track_len)

          ! done with this step, search the next one
          next_step = next_step + 1
          goto 10
        end if

        ! more than one candidate storm
        if (n_cand .gt. 1) then
          idx_0 = step_offsets(curr_step) + curr_storm

          r_lon_0 = r_lon(idx_0)
          r_lat_0 = abs(r_lat(idx_0))

          n_bon = 0

          do q = 1,n_cand
            idx_i = step_offsets(cand_step(q)) + cand_storm(q)

            r_lon_i = r_lon(idx_i)
            r_lat_i = abs(r_lat(idx_i))

            ! TODO -- is this the periodic bc in lon dir??
            ! mod to deal with 0 lon (from gfdl 2015)
            !if ((sin(r_lon_i) <= sin(r_lon_0)) &
            ! here is teca 1 condition
            if ((r_lon_i <= r_lon_0) &
              .and. (r_lat_i >= r_lat_0)) then
              n_bon = n_bon + 1
              bon_step(n_bon) = cand_step(q)
              bon_storm(n_bon) = cand_storm(q)
            end if
          end do

          if (n_bon .eq. 1) then
            ! add the storm to the track
            track_len = track_len + 1
            track_step(track_len) = bon_step(1)
            track_storm(track_len) = bon_storm(1)

            curr_step = track_step(track_len)
            curr_storm = track_storm(track_len)

            ! done with this step, search the next one
            next_step = next_step + 1
            goto 10
          end if

          if (n_bon .gt. 1) then
            ! take the closest
            idx_0 = step_offsets(curr_step) + curr_storm
            r_lon_0 = r_lon(idx_0)
            r_lat_0 = r_lat(idx_0)

            do q = 1,n_bon
              idx_i = step_offsets(bon_step(q)) + bon_storm(q)

              r_lon_i = r_lon(idx_i)
              r_lat_i = r_lat(idx_i)

              rtot(q) = distance_@type_name@( &
                r_lon_0, r_lat_0, r_lon_i, r_lat_i)
            end do
            imin = minloc(rtot(1:n_bon))

            ! add to track
            track_len = track_len + 1
            track_step(track_len) = bon_step(imin(1))
            track_storm(track_len) = bon_storm(imin(1))

            ! done with this step, search the next one
            curr_step = track_step(track_len)
            curr_storm = track_storm(track_len)
            next_step  = next_step + 1
            goto  10
          end if

          if (n_bon .eq. 0) then
            ! take the closest
            idx_0 = step_offsets(curr_step) + curr_storm

            r_lon_0 = r_lon(idx_0)
            r_lat_0 = r_lat(idx_0)

            do q = 1,n_cand
              idx_i = step_offsets(cand_step(q)) + cand_storm(q)

              r_lon_i = r_lon(idx_i)
              r_lat_i = r_lat(idx_i)

              rtot(q) = distance_@type_name@( &
                r_lon_0, r_lat_0, r_lon_i, r_lat_i)
            end do
            imin = minloc(rtot(1:n_cand))

            ! add to track
            track_len = track_len + 1
            track_step(track_len) = cand_step(imin(1))
            track_storm(track_len) = cand_storm(imin(1))

            ! done with this step, search the next one
            curr_step = track_step(track_len)
            curr_storm = track_storm(track_len)
            next_step = next_step + 1
            goto  10

          endif
        end if
      end if
    end do
    write(error_unit, '(A1)')'done!'
  end do

  ! TODO -- these would go in downstream algorithms
  ! --- FILTER DATA
  !if (do_filt) CALL TS_FILTER(nlat,slat)
  ! --- STATS
  !call TS_STATS(do_filt)

  ret_val = 0
  return
end function
end module
