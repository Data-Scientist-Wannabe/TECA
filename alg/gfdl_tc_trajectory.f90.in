module gfdl_tc_trajectory
use iso_c_binding
use iso_fortran_env, ONLY : error_unit
implicit none

interface
!-----------------------------------------------------------------------------
subroutine teca_append_track_@type_name@(table, track_id, &
  step, time, storm_id, lon, lat, psl, wind, vort, &
  have_twc, have_thick, twc, thick_mess) bind(C)
  use iso_c_binding
  implicit none
  type(c_ptr), intent(inout) :: table
  integer(c_long), intent(in) :: step
  real(c_double), intent(in) :: time
  real(@c_type_coord@), intent(in) :: lon, lat
  integer(c_int), intent(in) :: track_id, storm_id, have_twc, have_thick
  real(@c_type_var@), intent(in) :: psl, wind, vort, twc, thick
end subroutine
end interface

!-----------------------------------------------------------------------------
subroutine get_step_offsets(step_ids, n_rows, &
  n_steps, step_counts, step_offsets)
  implicit none
  integer(c_int), intent(in), dimension(n_rows) :: step_ids
  integer(c_long), intent(in) :: n_rows
  integer(c_long), intent(out) :: n_steps
  integer(c_long), intent(out), dimension(:) :: &
    step_counts, step_offsets
  integer(c_long) :: q, i, n_m1

  ! count unique number of steps
  n_steps = 1
  n_m1 = n_rows - 1
  do i = 1,n_m1
    if (step_ids(i) .ne. step_ids(i+1)) &
      n_steps = n_steps + 1
  enddo

  ! compute num storms in each step
  q = 1
  do i = 1,n_steps
    do while ((step_ids(q) .ne. step_ids(q+1)) &
      .and. (q .le. n_rows))
      q = q + 1
    enddo
    step_counts(i) = q
    q = q + 1
  enddo

  ! compute offset to first storm at each step
  step_offsets(1) = 1
  do i = 2,n_steps
    step_offset(i) = step_offset(i-1) + step_count(i-1)
  enddo
end subroutine

!-----------------------------------------------------------------------------
! defaults
!  r_crit  = 900.0
!  wind_crit  = 17.0
!  wind_max_crit = 17.0
!  vort_crit  = 3.5e-5  !miz
!  twc_crit   =  0.5 !miz
!  thick_crit =  50. !miz
!  n_wind_crit  =   2
!  do_filt = .true.
!  nlat =  40. !miz
!  slat = -40. !miz
integer(c_int) function gfdl_tc_trajectory_@type_name@( &
  r_crit, wind_crit, n_wind_crit, step, time, storm_id, &
  deg_lon, deg_lat, wind_max, vort_max, psl, have_twc, &
  have_thick, twc_max, thick_max, n_rows, track_table) &
  result(ret_val) bind(C)
  use iso_c_binding
  use iso_fortran_env, only : error_unit
  implicit none

  type(c_ptr), intent(in) :: track_table
  real(@c_coord_type@), intent(in) :: r_crit

  real(@c_var_type@), intent(in) :: wind_crit, wind_max_crit, &
    vort_crit, n_wind_crit

  integer(c_long), intent(in) :: n_rows

  real(@c_coord_type@), intent(in), dimension(n_rows) :: &
    deg_lon, deg_lat

  real(c_double), intent(in), dimension(n_rows) :: time
  integer(c_long), intent(in), dimension(n_rows) :: step

  real(@c_var_type@), intent(in), dimension(n_rows) :: &
    wind_max, vort_max, psl, twc_max, thick_max

  integer(c_int), intent(in), dimension(n_rows) :: &
    storm_id, have_twc, have_thick

  real(@c_coord_type) :: deg_lon_0, deg_lat_0, &
    deg_lon_i, deg_lat_i, dx, dy, dr, dt

  logical :: cross_equator

  integer(c_long) :: step, storm, n_steps, n_steps_m1, &
    offset, next_step, track_len, curr_step, curr_storm, &
    n_cand, n_bon, n_wind, n_wind_max, q

  integer(c_long), dimension(1) :: imin

  integer(c_long),dimension(n_rows) :: step_offsets, &
    step_counts

  integer(c_long), dimension(n_rows) :: &
    track_step, track_storm, cand_step, cand_storm, &
    bon_step, bon_storm

  real(@c_coord_type@), dimension(n_rows) :: rtot, rad_lon, rad_lat

  logical, dimension(n_rows) :: available, exist_wind, &
        exist_vort, exist_twc, exist_thick, exist_maxw

  real(@c_coord_type@), parameter :: &
    EARTH_RADIUS = 6371.0, DEG_TO_RAD = 3.14159265358979/180.0

  ret_val = -1

  ! --- STEP 1: Generate masks from critical values
  exist_wind(:) = (wind_max(:) .ge. wind_crit)
  exist_twc(:) = (have_twc(:) .ne. 0)
  exist_thick(:) = (have_thick(:) .ne. 0)
  rad_lon(:) = DEG_TO_RAD*deg_lon(:)
  rad_lat(:) = DEG_TO_RAD*deg_lat(:)
  available(:) = .true.

  ! --- STEP 2: EVALUATION OF TRAJECTORIES
  call get_step_offsets(step, n_rows, &
    n_steps, step_offsets, step_counts)

  n_steps_m1 = n_steps - 1
  do step = 1,n_steps_m1

    next_step = step + 1

    offset = step_offsets(step)

    ! for each candidate
    do storm = 1,step_counts(step)

      track_len = 1
      track_step(1) = step
      track_storm(1) = storm

      idx_0 = offset+storm
      if (available(idx_0) .and. exist_wind(idx_0)) then

        curr_step = step
        curr_storm = storm

        ! look forward in time at all steps for track candidates
10      continue
        n_cand = 0

        if (next_step .le. n_steps) then
          ! --- check for candidates on following day
          idx_0 = step_offsets(curr_step)+curr_storm
          rad_lon_0 = rad_lon(idx_0)
          rad_lat_0 = rad_lat(idx_0)

          dt = time(next_step) - time(step)

          ! build track candidate list. candidates must be
          ! close in space and time and not cross the equator
          do next_storm = 1,step_counts(next_step)

            idx_i = step_offsets(next_step)+next_storm

            if (available(idx_i)) then
              rad_lon_i = rad_lon(idx_i)
              rad_lat_i = rad_lat(idx_i)

              drdt = EARTH_RADIUS*acos(sin(rad_lat_0)*sin(rad_lat_i) &
                + cos(rad_lat_0)*cos(rad_lat_i)*cos(rad_lon_i - rad_lon_0))/dt

              cross_equator = (rad_lat_i*rad_lat_0 .le. 0.0)

              if ((drdt .le. r_crit) .and. (.not. cross_equator)) then
                n_cand = n_cand + 1
                cand_step(n_cand) = next_step
                cand_storm(n_cand) = next_storm
              end if
            end if
          end do
        endif

        ! no more candidate storms, end of the track
        if (n_cand .eq. 0) then
          ! check sustained winds along the trajectory
          n_wind = 0
          !n_wind_max = 0
          n_twc = 0
          n_thick = 0
          do q = 1,track_len
            idx_0 = step_offsets(track_step(q))+track_storm(q)

            if (exist_wind(idx_0) .and. &
              exist_twc(idx_0) .and. exist_thick(idx_0)) &
              n_wind = n_wind + 1

            if (exist_twc(idx_0)) &
              n_twc = n_twc + 1

            if (exist_thick(idx_0)) &
              n_thick = n_thick + 1

          end do

          dt = time(next_step) - time(step)
          if ((track_len .gt. 1) .and. ((n_wind*dt) .ge. n_wind_crit) then
            ! track meets the wind duration criteria

            do q = 1,track_len
              idx_0 = step_offsets(track_step(q)) + track_storm(q)

              ! output trajectory info
              call teca_append_tc_track_@type_name@( &
                track_table, track_id, step(idx_0), time(idx_0), &
                storm_id(idx_0), deg_lon(idx_0), deg_lat(idx_0), &
                psl(idx_0), wind_max(idx_0), vort_max(idx_0), &
                have_twc(idx_0), have_thick(idx_0), twc_max(idx_0), &
                thick_max(idx_0))

              ! mark candidate as used
              available(idx_0) = .false.
            end do

            track_id = track_id + 1
          end if
        end if

        ! one candidate storm, add it to the track
        if (n_cand .eq. 1) then

          track_len = track_len + 1
          track_step(track_len) = cand_step(1)
          track_storm(track_len) = cand_storm(1)

          curr_step = track_step(track_len)
          curr_storm = track_storm(track_len)

          ! done with this step, search the next one
          next_step = next_step + 1
          goto 10
        end if

        ! more than one candidate storm
        if (n_cand .gt. 1) then

          idx_0 = step_offsets(curr_step) + curr_storm

          rad_lon_0 = rad_lon(idx_0)
          rad_lat_0 = abs(rad_lat(idx_0))

          n_bon = 0

          do q = 1,n_cand

            idx_i = step_offsets(cand_step(q)) + cand_storm(q)

            rad_lon_i = rad_lon(idx_i)
            rad_lat_i = abs(rad_lat(idx_i))

            ! TODO -- is this the periodic bc in lon dir??
            ! mod to deal with 0 lon (from gfdl 2015)
            !if ((sin(rad_lon_i) <= sin(rad_lon_0)) &
            ! here is teca 1 condition
            if ((rad_lon_i <= rad_lon_0) &
              .and. (rad_lat_i >= rad_lat_0)) then
              n_bon = n_bon + 1
              bon_step(n_bon) = cand_step(q)
              bon_storm(n_bon) = cand_storm(q)
            end if
          end do

          if (n_bon .eq. 1) then
            ! add the storm to the track
            track_len = track_len + 1
            track_step(track_len) = bon_step(1)
            track_storm(track_len) = bon_storm(1)

            curr_step = track_step(track_len)
            curr_storm = track_storm(track_len)

            ! done with this step, search the next one
            next_step = next_step + 1
            goto 10
          end if

          if (n_bon .gt. 1) then
            ! take the closest
            idx_0 = step_offsets(curr_step) + curr_storm
            rad_lon_0 = rad_lon(idx_0)
            rad_lat_0 = rad_lat(idx_0)

            do q = 1,n_bon
              idx_i = step_offsets(bon_step(q)) + bon_storm(q)

              rad_lon_i = rad_lon(idx_i)
              rad_lat_i = rad_lat(idx_i)

              rtot(q) = EARTH_RADIUS*acos(sin(rad_lat_i)*sin(rad_lat_0) &
                + cos(rad_lat_i)*cos(rad_lat_0)*cos(rad_lon_i - rad_lon_0))
            end do
            imin = minloc(rtot(1:n_bon))

            ! add to track
            track_len = track_len + 1
            track_step(track_len) = bon_step(imin(1))
            track_storm(track_len) = bon_storm(imin(1))

            ! done with this step, search the next one
            curr_step = track_step(track_len)
            curr_storm = track_storm(track_len)
            next_step  = next_step + 1
            goto  10
          end if

          if (n_bon .eq. 0) then
            ! take the closest
            idx_0 = step_offsets(curr_step) + curr_storm

            rad_lon_0 = rad_lon(idx_0)
            rad_lat_0 = rad_lat(idx_0)

            do q = 1,n_cand
              idx_i = step_offsets(cand_step(q)) + cand_strom(q)

              rad_lon_i = rad_lon(idx_i)
              rad_lat_i = rad_lat(idx_i)

              rtot(q) = EARTH_RADIUS*acos(sin(rad_lat_i)*sin(rad_lat_0) &
                + cos(rad_lat_i)*cos(rad_lat_0)*cos(rad_lon_i - rad_lon_0))
            end do
            imin = minloc(rtot(1:n_cand))

            ! add to track
            track_len = track_len + 1
            track_step(track_len) = cand_step(imin(1))
            track_storm(track_len) = cand_storm(imin(1))

            ! done with this step, search the next one
            curr_step = track_step(track_len)
            curr_storm = track_storm(track_len)
            next_step = next_step + 1
            goto  10

          endif
        end if
      end if
    end do
  end do

  ! TODO -- these would go in downstream algorithms
  ! --- FILTER DATA
  !if (do_filt) CALL TS_FILTER(nlat,slat)
  ! --- STATS
  !call TS_STATS(do_filt)

  ret_val = 0
  return
end function
end module
